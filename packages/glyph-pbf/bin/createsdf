#!/usr/bin/env node
var cluster = require("cluster");
var path = require("path");
var fs = require("fs");
var zlib = require("zlib");
var argv = require("minimist")(process.argv.slice(2));
var opentype = require("opentype.js");
var Protobuf = require("pbf");
var sdf = require("../lib/sdf").glyphToSDF;

function usage() {
  console.warn("Usage: %s [args] [font file]...", path.relative(process.cwd(), process.argv[1]));
  console.warn("  --min [chr]\t Minimum char code to generate");
  console.warn("  --max [chr]\t Minimum char code to generate");
  console.warn("  --workers [count]\t Number of concurrent worders");
  process.exit(1);
}

var fontSize = 24;
var buffer = 3;
var cutoff = 2 / 8;

var minchr = +(argv.min || 0);
var maxchr = +(argv.max || 65535);
var workers = +(argv.workers || require("os").cpus().length);

var from = minchr - (minchr % 256);

var fonts = argv._;
if (!fonts.length) {
  usage();
}

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i < workers; i++) {
    cluster.fork().on("message", function (msg) {
      if (msg.type === "work") {
        if (from < maxchr) {
          this.send({ type: "chunk", from: from });
          from += 256;
        } else {
          this.send({ type: "exit" });
        }
      }
    });
  }
} else {
  fonts = fonts
    .map((filename) => {
      var data = fs.readFileSync(filename);
      var font = opentype.parse(new Uint8Array(data).buffer);
      font.filename = filename;
      return font;
    })
    .filter((font) => {
      if (!font.supported) {
        console.warn(font.filename + " is not supported.");
        return false;
      } else {
        return true;
      }
    });

  var basename = fonts
    .map(
      (font) =>
        (font.tables.name.preferredFamily || font.tables.name.fontFamily) +
        " " +
        (font.tables.name.preferredSubfamily || font.tables.name.fontSubfamily),
    )
    .join(", ");

  try {
    fs.mkdirSync(basename);
  } catch (err) {
    if (err.code != "EEXIST") {
      throw err;
    }
  }
  process.on("message", (msg) => {
    if (msg.type === "chunk") {
      createGlyphs(msg.from, msg.from + 255, () => {
        process.send({ type: "work" });
      });
    } else if (msg.type === "exit") {
      process.exit(0);
    }
  });

  // Request the initial work package.
  process.send({ type: "work" });
}

function createGlyphs(from, to, callback) {
  var out = path.join(basename, from + "-" + to + ".pbf");
  console.warn("Generating " + out);

  var fontstack_pbf = new Protobuf(new Buffer(16384));
  fontstack_pbf.writeTaggedString(/* name */ 1, basename);
  fontstack_pbf.writeTaggedString(/* range */ 2, from + "-" + to);

  for (var chr = from; chr <= to; chr++) {
    for (var i = 0; i < fonts.length; i++) {
      var font = fonts[i];
      var glyph = font.charToGlyph(String.fromCharCode(chr));
      if (glyph.index > 0) {
        var info = sdf(glyph, fontSize, buffer, cutoff);
        var glyph_pbf = new Protobuf(new Buffer(512));
        glyph_pbf.writeTaggedVarint(/* id */ 1, chr);
        if (info.data) {
          glyph_pbf.writeTaggedBuffer(/* bitmap */ 2, new Buffer(info.data));
        }
        glyph_pbf.writeTaggedVarint(/* width */ 3, info.glyphWidth);
        glyph_pbf.writeTaggedVarint(/* height */ 4, info.glyphHeight);
        glyph_pbf.writeTaggedSVarint(/* left */ 5, info.glyphBearingX);
        glyph_pbf.writeTaggedSVarint(/* top */ 6, info.glyphTop);
        glyph_pbf.writeTaggedVarint(/* advance */ 7, info.glyphAdvance);

        fontstack_pbf.writeMessage(/* glyphs */ 3, glyph_pbf);
        break;
      }
    }
  }

  var glyphs_pbf = new Protobuf(new Buffer(fontstack_pbf.pos + 8));
  glyphs_pbf.writeMessage(/* stacks */ 1, fontstack_pbf);

  zlib.deflate(glyphs_pbf.finish(), (err, data) => {
    if (err) console.warn(err.stack);
    fs.writeFile(out, data, (err) => {
      if (err) console.warn(err.stack);
      callback();
    });
  });
}
